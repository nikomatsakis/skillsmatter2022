# Key takeaways

* Rust is for people who value reliability, performance, and long-term maintenance
* Rust is an empowerer
* Rust is always evolving
* Rust has a learning cur ve, it will take some time
    * Type system models things you're not accustomed to

    
* Hack without fear

# Narrative

* Hi, I'm Niko. I've been working on Rust since 2011 -- quite a long time, really. 
* I'm the co-lead of the Rust language design team.
* Why work on Rust so long?
    * Is it just that I love me a fancy type system?
    * Well, as it happens, I do, but that's not really it.
    * The reason is simple: I like to see people build cool stuff, and Rust is a great tool for that.
* Rust's mission is to empower
    * "Rust: A language empowering everyone to build reliable and efficient software."

    * Rust: a 
* Rust is starting to show up all over the place
    * Just look at the sponsors of the Rust foundation:
        * ...
    * Rust usage is at 7% on 2022 SO, up from 5% and then 2%.
* If you're listening to this, you're probably interested in using Rust, but you might be wondering: what kinds of things is Rust good for? When should I use Rust?
    * My answer: Programs where performance, reliability, and long-term maintenance are top considerations
* What are people building with Rust? Well, all sorts of things
    * Networking (Discord, AWS, Azure...)
    * Embedded applications, kernel modules
    * CLI tooling
* 

* What's that 
* 



# Narrative

* Hi! I'm Niko. 
    * Been working on Rust since 2011. A surprisingly long time.
    * Someone recently asked me why I work on Rust. The answer, of course, is that I enjoy it -- but why?
* Rust the empowerer
    * 
    * It's still interesting.
* 
    * I've been working on Rust since 2022
* I'm here to talk to you today about Rust 2024
* Why 2024?
* Maybe you've heard 
* Maybe you've heard that Rust has been named the Most Loved language since 2015 (when we released 1.0)
* Rust is growing fast
    * doubling each year in SO survey
    * 2.2million users elsewhere
    * growing particularly fast amongst startups, who don't have legacy code to worry about
* What are people doing with Rust?
    * Well, kind of everything
    * Networking is a big area
        * Discord
        * AWS
        * Azure
        * ...
    * Embedded
    * Portability across phones, common core for a API
    * Kernel hacking
    * CLI tooling
        * ripgrep, etc
* Why are people adopting Rust?
    * Performance and reliability
        * "If it compiles, it works, and it runs pretty fast"
        * Discord: 
            * switching from Go to Rust saved N%
            * they then did some rearchitecting and got M%
        * Tenable
            * switched from node.js to Rust, saved Mx
        * AWS
            * used in S3, EC2, Lambda, ...
* What do they find when they do?
    * Supportive and versatile
        * Compiler error messages
        * Embedded tooling
    * Long-term maintenance
        * Refactoring
    * Combination of all of these things: *Empowering*
        * Able to do more than you could before
        * Stylo
* What is Rust for?
    * Projects that prize performance, reliability, and long-term maintenance
    * If you don't care about some of those, Rust may not be great
* Don't care about performance?
    * Rust exposes details you may not care about
        * e.g., stack allocation
* Don't care about reliability?
    * You may not like exhaustive matches, forcing you to handle errors, etc
* Don't care about long-term maintenance?
    * Scripts 
* Rust, a journey
    * Rust 2015: 1.0
        * 
    * Rust 2018: NLL
        * 
    * Rust 2021: refinements
* Definitely still some challenges
    * 
    * Rust 2024: ...?
* Learning curve, incomplete
* 
* Every rose has its thorn
    * Rust isn't great for everything
    * Compilation time remains an issue
    * Rust takes time to learn
        * 3-6 months, and I ain't gonna lie, it is not easy
    * Rust exposes details that may not matter to you
* Rust 2024
    * What will it be like? I don't know
    * But I've got some ideas
* Async parity
* Easier to use, less rigamarole
* How you can help




editions?
